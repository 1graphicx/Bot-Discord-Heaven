import discord
from discord.ext import commands
from discord import app_commands
from datetime import datetime
import platform
import logging

# R√àGLE : Les commandes slash sont automatiquement enregistr√©es par bot.add_cog()

# Gestion optionnelle de psutil
try:
    import psutil
    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False

logger = logging.getLogger("bot.utilities")

class Utilities(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot

    @app_commands.command(name="ping", description="Afficher la latence du bot")
    async def ping_slash(self, interaction: discord.Interaction):
        try:
            embed = discord.Embed(
                title="üèì **Pong!**",
                description=f"Latence: **{round(self.bot.latency * 1000)}ms**",
                color=discord.Color.green(),
                timestamp=datetime.now()
            )
            embed.set_footer(text=f"Bot: {self.bot.user.name}")
            await interaction.response.send_message(embed=embed, ephemeral=True)
        except Exception as e:
            logger.error(f"Erreur commande ping: {e}")
            await interaction.response.send_message("‚ùå **Erreur lors de la v√©rification de la latence.**", ephemeral=True)

    @app_commands.command(name="userinfo", description="Afficher les informations d'un utilisateur")
    @app_commands.describe(member="Membre dont voir les informations")
    async def userinfo_slash(self, interaction: discord.Interaction, member: discord.Member = None):
        try:
            # R√©pondre imm√©diatement pour √©viter le timeout
            await interaction.response.defer(ephemeral=True)
            
            if member is None:
                member = interaction.user
            
            roles = [role.mention for role in member.roles[1:]]  # Exclure @everyone
            roles_str = " ".join(roles) if roles else "Aucun r√¥le"
            
            embed = discord.Embed(
                title=f"üë§ **Informations de {member.display_name}**",
                color=member.color,
                timestamp=datetime.now()
            )
            embed.set_thumbnail(url=member.display_avatar.url)
            embed.add_field(name="Nom d'utilisateur", value=f"`{member.name}`", inline=True)
            embed.add_field(name="ID", value=f"`{member.id}`", inline=True)
            embed.add_field(name="Surnom", value=f"`{member.nick or 'Aucun'}`", inline=True)
            embed.add_field(name="Compte cr√©√© le", value=f"<t:{int(member.created_at.timestamp())}:R>", inline=True)
            embed.add_field(name="A rejoint le", value=f"<t:{int(member.joined_at.timestamp())}:R>", inline=True)
            embed.add_field(name="R√¥les", value=roles_str[:1024] if len(roles_str) <= 1024 else roles_str[:1021] + "...", inline=False)
            
            await interaction.followup.send(embed=embed, ephemeral=True)
        except Exception as e:
            logger.error(f"Erreur commande userinfo: {e}")
            if not interaction.response.is_done():
                await interaction.response.send_message("‚ùå **Erreur lors de la r√©cup√©ration des informations utilisateur.**", ephemeral=True)
            else:
                await interaction.followup.send("‚ùå **Erreur lors de la r√©cup√©ration des informations utilisateur.**", ephemeral=True)

    @app_commands.command(name="serverinfo", description="Afficher les informations du serveur")
    async def serverinfo_slash(self, interaction: discord.Interaction):
        try:
            # R√©pondre imm√©diatement pour √©viter le timeout
            await interaction.response.defer(ephemeral=True)
            
            guild = interaction.guild
            
            # Statistiques des canaux
            text_channels = len(guild.text_channels)
            voice_channels = len(guild.voice_channels)
            categories = len(guild.categories)
            
            # Statistiques des membres (optimis√©)
            total_members = guild.member_count
            online_members = len([m for m in guild.members if m.status != discord.Status.offline])
            
            embed = discord.Embed(
                title=f"üè† **Informations de {guild.name}**",
                color=discord.Color.blue(),
                timestamp=datetime.now()
            )
            if guild.icon:
                embed.set_thumbnail(url=guild.icon.url)
            
            embed.add_field(name="Propri√©taire", value=guild.owner.mention, inline=True)
            embed.add_field(name="ID du serveur", value=f"`{guild.id}`", inline=True)
            embed.add_field(name="Cr√©√© le", value=f"<t:{int(guild.created_at.timestamp())}:R>", inline=True)
            embed.add_field(name="Membres", value=f"üë• {total_members} total\nüü¢ {online_members} en ligne", inline=True)
            embed.add_field(name="Canaux", value=f"üí¨ {text_channels} textuels\nüîä {voice_channels} vocaux\nüìÅ {categories} cat√©gories", inline=True)
            embed.add_field(name="R√¥les", value=f"üé≠ {len(guild.roles)} r√¥les", inline=True)
            
            if guild.description:
                embed.add_field(name="Description", value=guild.description[:1024], inline=False)
            
            await interaction.followup.send(embed=embed, ephemeral=True)
        except Exception as e:
            logger.error(f"Erreur commande serverinfo: {e}")
            if not interaction.response.is_done():
                await interaction.response.send_message("‚ùå **Erreur lors de la r√©cup√©ration des informations du serveur.**", ephemeral=True)
            else:
                await interaction.followup.send("‚ùå **Erreur lors de la r√©cup√©ration des informations du serveur.**", ephemeral=True)

    @app_commands.command(name="avatar", description="Afficher l'avatar d'un utilisateur")
    @app_commands.describe(member="Membre dont voir l'avatar")
    async def avatar_slash(self, interaction: discord.Interaction, member: discord.Member = None):
        try:
            if member is None:
                member = interaction.user
            
            embed = discord.Embed(
                title=f"üñºÔ∏è **Avatar de {member.display_name}**",
                color=member.color,
                timestamp=datetime.now()
            )
            embed.set_image(url=member.display_avatar.url)
            embed.add_field(name="Lien direct", value=f"[Cliquer ici]({member.display_avatar.url})", inline=True)
            
            await interaction.response.send_message(embed=embed, ephemeral=True)
        except Exception as e:
            logger.error(f"Erreur commande avatar: {e}")
            await interaction.response.send_message("‚ùå **Erreur lors de la r√©cup√©ration de l'avatar.**", ephemeral=True)

    @app_commands.command(name="botinfo", description="Afficher les informations du bot")
    async def botinfo_slash(self, interaction: discord.Interaction):
        try:
            # R√©pondre imm√©diatement pour √©viter le timeout
            await interaction.response.defer(ephemeral=True)
            
            # Statistiques du bot
            total_servers = len(self.bot.guilds)
            total_users = sum(len(guild.members) for guild in self.bot.guilds)
            
            # Statistiques syst√®me (si psutil disponible)
            if PSUTIL_AVAILABLE:
                try:
                    cpu_percent = psutil.cpu_percent()
                    memory = psutil.virtual_memory()
                    memory_percent = memory.percent
                    system_info = f"üñ•Ô∏è CPU: **{cpu_percent}%**\nüíæ RAM: **{memory_percent}%**"
                except Exception as e:
                    logger.error(f"Erreur r√©cup√©ration stats syst√®me: {e}")
                    system_info = "üíª Syst√®me: Erreur de r√©cup√©ration"
            else:
                system_info = "üíª Syst√®me: Indisponible"
            
            embed = discord.Embed(
                title="ü§ñ **Informations du Bot**",
                description=f"**{self.bot.user.name}** - Bot Discord professionnel",
                color=discord.Color.purple(),
                timestamp=datetime.now()
            )
            embed.set_thumbnail(url=self.bot.user.display_avatar.url)
            
            embed.add_field(name="üìä Statistiques", value=f"üñ•Ô∏è **{total_servers}** serveurs\nüë• **{total_users}** utilisateurs", inline=True)
            embed.add_field(name="üíª Syst√®me", value=system_info, inline=True)
            embed.add_field(name="üîß Technique", value=f"üêç Python: **{platform.python_version()}**\nüìö Discord.py: **{discord.__version__}**", inline=True)
            embed.add_field(name="‚è±Ô∏è Uptime", value=f"<t:{int(self.bot.start_time.timestamp())}:R>", inline=True)
            embed.add_field(name="üèì Latence", value=f"**{round(self.bot.latency * 1000)}ms**", inline=True)
            
            embed.set_footer(text="Bot d√©velopp√© avec ‚ù§Ô∏è")
            
            await interaction.followup.send(embed=embed, ephemeral=True)
        except Exception as e:
            logger.error(f"Erreur commande botinfo: {e}")
            if not interaction.response.is_done():
                await interaction.response.send_message("‚ùå **Erreur lors de la r√©cup√©ration des informations du bot.**", ephemeral=True)
            else:
                await interaction.followup.send("‚ùå **Erreur lors de la r√©cup√©ration des informations du bot.**", ephemeral=True)

    @app_commands.command(name="roleinfo", description="Afficher les informations d'un r√¥le")
    @app_commands.describe(role="R√¥le dont voir les informations")
    async def roleinfo_slash(self, interaction: discord.Interaction, role: discord.Role):
        try:
            # R√©pondre imm√©diatement pour √©viter le timeout
            await interaction.response.defer(ephemeral=True)
            
            # Compter les membres avec ce r√¥le
            member_count = len(role.members)
            
            # Permissions importantes
            permissions = []
            if role.permissions.administrator:
                permissions.append("üëë Administrateur")
            if role.permissions.manage_guild:
                permissions.append("‚öôÔ∏è G√©rer le serveur")
            if role.permissions.manage_channels:
                permissions.append("üìù G√©rer les canaux")
            if role.permissions.manage_messages:
                permissions.append("üí¨ G√©rer les messages")
            if role.permissions.ban_members:
                permissions.append("üî® Bannir des membres")
            if role.permissions.kick_members:
                permissions.append("üë¢ Expulser des membres")
            
            permissions_str = "\n".join(permissions) if permissions else "Aucune permission sp√©ciale"
            
            embed = discord.Embed(
                title=f"üé≠ **Informations du r√¥le {role.name}**",
                color=role.color,
                timestamp=datetime.now()
            )
            embed.add_field(name="ID", value=f"`{role.id}`", inline=True)
            embed.add_field(name="Couleur", value=f"`{str(role.color)}`", inline=True)
            embed.add_field(name="Position", value=f"`{role.position}`", inline=True)
            embed.add_field(name="Membres", value=f"üë• **{member_count}** membres", inline=True)
            embed.add_field(name="Mentionnable", value="‚úÖ Oui" if role.mentionable else "‚ùå Non", inline=True)
            embed.add_field(name="Affich√© s√©par√©ment", value="‚úÖ Oui" if role.hoist else "‚ùå Non", inline=True)
            embed.add_field(name="Cr√©√© le", value=f"<t:{int(role.created_at.timestamp())}:R>", inline=True)
            embed.add_field(name="Permissions importantes", value=permissions_str, inline=False)
            
            await interaction.followup.send(embed=embed, ephemeral=True)
        except Exception as e:
            logger.error(f"Erreur commande roleinfo: {e}")
            if not interaction.response.is_done():
                await interaction.response.send_message("‚ùå **Erreur lors de la r√©cup√©ration des informations du r√¥le.**", ephemeral=True)
            else:
                await interaction.followup.send("‚ùå **Erreur lors de la r√©cup√©ration des informations du r√¥le.**", ephemeral=True)

    @app_commands.command(name="channelinfo", description="Afficher les informations d'un canal")
    @app_commands.describe(channel="Canal dont voir les informations")
    async def channelinfo_slash(self, interaction: discord.Interaction, channel: discord.TextChannel = None):
        try:
            if channel is None:
                channel = interaction.channel
            
            # R√©pondre imm√©diatement pour √©viter le timeout
            await interaction.response.defer(ephemeral=True)
            
            # Compter les messages (approximatif avec limite de s√©curit√©)
            try:
                message_count = 0
                async for _ in channel.history(limit=100):  # R√©duit √† 100 pour plus de rapidit√©
                    message_count += 1
                    if message_count >= 100:
                        message_count = "100+"
                        break
            except discord.Forbidden:
                message_count = "Acc√®s refus√©"
            except Exception as e:
                logger.error(f"Erreur comptage messages: {e}")
                message_count = "Erreur"
            
            embed = discord.Embed(
                title=f"üìù **Informations du canal #{channel.name}**",
                color=discord.Color.blue(),
                timestamp=datetime.now()
            )
            embed.add_field(name="ID", value=f"`{channel.id}`", inline=True)
            embed.add_field(name="Type", value=f"üí¨ Canal textuel", inline=True)
            embed.add_field(name="Position", value=f"`{channel.position}`", inline=True)
            embed.add_field(name="Cat√©gorie", value=f"`{channel.category.name if channel.category else 'Aucune'}`", inline=True)
            embed.add_field(name="Messages", value=f"üí¨ **{message_count}**", inline=True)
            embed.add_field(name="Cr√©√© le", value=f"<t:{int(channel.created_at.timestamp())}:R>", inline=True)
            
            if channel.topic:
                embed.add_field(name="Description", value=channel.topic[:1024], inline=False)
            
            await interaction.followup.send(embed=embed, ephemeral=True)
        except Exception as e:
            logger.error(f"Erreur commande channelinfo: {e}")
            if not interaction.response.is_done():
                await interaction.response.send_message("‚ùå **Erreur lors de la r√©cup√©ration des informations du canal.**", ephemeral=True)
            else:
                await interaction.followup.send("‚ùå **Erreur lors de la r√©cup√©ration des informations du canal.**", ephemeral=True)


async def setup(bot: commands.Bot):
    await bot.add_cog(Utilities(bot))
